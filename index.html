<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Egzamin Algorytmy - Symulator</title>
    <style>
        body {
            background-color: #131314;
            color: #e3e3e3;
            font-family: 'Google Sans', Roboto, Arial, sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }
        
        .container {
            width: 100%;
            max-width: 800px;
            padding: 20px;
        }

        /* Pasek postępu i nagłówek */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 40px;
            font-size: 14px;
            color: #9aa0a6;
        }

        .progress-bar {
            flex-grow: 1;
            height: 4px;
            background-color: #303134;
            border-radius: 2px;
            margin-right: 20px;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background-color: #8ab4f8;
            width: 0%;
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .score-badge {
            background-color: #1e1f20;
            padding: 4px 12px;
            border-radius: 16px;
            display: flex;
            gap: 10px;
            font-weight: bold;
        }
        .score-correct { color: #81c995; }
        .score-wrong { color: #f28b82; }

        /* Pytanie */
        .question-text {
            font-size: 20px;
            line-height: 1.5;
            margin-bottom: 40px;
            font-weight: 500;
        }

        .category-label {
            color: #8ab4f8;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            display: block;
        }

        /* Odpowiedzi */
        .options-grid {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .option-btn {
            background-color: #1e1f20;
            border: 1px solid transparent;
            border-radius: 8px;
            padding: 16px 24px;
            color: #e3e3e3;
            text-align: left;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
        }

        .option-btn:hover {
            background-color: #303134;
        }

        .option-letter {
            font-weight: bold;
            margin-right: 16px;
            color: #9aa0a6;
        }

        /* Stany odpowiedzi */
        .option-btn.correct {
            background-color: #132a1c; /* Ciemny zielony */
            border-color: #81c995;
            color: #81c995;
        }
        
        .option-btn.wrong {
            background-color: #3c1e1e; /* Ciemny czerwony */
            border-color: #f28b82;
            color: #f28b82;
        }
        
        .option-btn.disabled {
            pointer-events: none;
            opacity: 0.6;
        }

        /* Przycisk Dalej */
        .next-btn-container {
            display: flex;
            justify-content: flex-end;
            margin-top: 30px;
        }

        .next-btn {
            background-color: #8ab4f8;
            color: #202124;
            border: none;
            padding: 10px 24px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            display: none; /* Ukryty dopóki nie odpowiesz */
        }

        .next-btn:hover {
            background-color: #aecbfa;
        }

        /* Ekran końcowy */
        .results {
            text-align: center;
            display: none;
        }
        .results h1 { font-size: 32px; margin-bottom: 20px; }
        .result-item { margin: 10px 0; font-size: 18px; color: #9aa0a6; }
        .pass { color: #81c995; font-weight: bold; }
        .fail { color: #f28b82; font-weight: bold; }

    </style>
</head>
<body>

<div class="container" id="quiz-container">
    <div class="header">
        <div class="progress-bar">
            <div class="progress-fill" id="progress"></div>
        </div>
        <div id="counter">1 / 36</div>
        <div class="score-badge" style="margin-left: 15px;">
            <span class="score-wrong">✕ <span id="wrong-count">0</span></span>
            <span class="score-correct">✔ <span id="correct-count">0</span></span>
        </div>
    </div>

    <span class="category-label" id="category-label">Efekt W1 - Podstawy</span>
    <div class="question-text" id="question-text">
        Ładowanie pytania...
    </div>

    <div class="options-grid" id="options-container">
        </div>

    <div class="next-btn-container">
        <button class="next-btn" id="next-btn" onclick="nextQuestion()">Dalej</button>
    </div>
</div>

<div class="container results" id="results-screen">
    <h1>Wyniki Egzaminu</h1>
    <div id="results-details"></div>
    <button class="next-btn" style="display:inline-block; margin-top:20px;" onclick="location.reload()">Spróbuj ponownie</button>
</div>

<script>
    const questions = [

    {
    cat:"W1",
    q:"1. (W1/3) Jeśli funkcja kosztu czasowego pewnego algorytmu iteracyjnego jest postaci C(n)=4n^2+2n+3 (gdzie n to rozmiar charakterystyczny zadania) i algorytm wykorzystuje zawsze pamięć w postaci 8 zmiennych, to złożoność obliczeniowa czasowa tego algorytmu jest rzędu:",
    options:[
    "A. Θ(1)",
    "B. Θ(n)",
    "C. Θ(n^2)",
    "D. Θ(n^3)"
    ],
    correct:2
    },

    {
    cat:"W1",
    q:"2. (W1/3) Jeśli złożoności obliczeniowe 3 algorytmów są odpowiednio rzędu: Θ(n^2), Θ(log n), Θ(2^n), to są to algorytmy:",
    options:[
    "A. kwadratowy, logarytmiczny, wykładniczy",
    "B. wielomianowy, logarytmiczny, potęgowy",
    "C. kwadratowy, logarytmiczny, dwójkowy",
    "D. żadna z odpowiedzi nie jest do końca prawdziwa."
    ],
    correct:0
    },

    {
    cat:"W1",
    q:"3. (W1/3) Klasa problemów z punktu widzenia złożoności obliczeniowej zawierająca problemy decyzyjne, z których każdy problem należy do klasy NP, nie jest dla niego znany algorytm rozwiązujący ten problem w czasie wielomianowym oraz dowolny problem należący do NP może być do niego zredukowany w czasie wielomianowym nazywa się:",
    options:[
    "A. klasa P problemów",
    "B. klasa NP problemów",
    "C. klasa problemów NP-trudnych",
    "D. klasa problemów NP-zupełnych."
    ],
    correct:3
    },

    {
    cat:"W1",
    q:"4. (W1/4) Które z poniższych uszeregowań rzędów złożoności obliczeniowej od najmniej efektywnych do najbardziej efektywnych czasowo jest poprawne:",
    options:[
    "A. O(n^2), O(log n), O(2^n)",
    "B. O(2^n), O(n^2), O(n log n)",
    "C. O(n^2), O(log n), O(1)",
    "D. O(n^2), O(n), O(n log n)"
    ],
    correct:1
    },

    {
    cat:"W1",
    q:"5. (W1/4) Który z poniższych zestawów inkluzji jest w pełni niepoprawny:",
    options:[
    "A. NP⊂P, NP⊂NP-zupełne, P-SPACE⊂P",
    "B. P⊂NP, NP-zupełne⊂NP, NP-SPACE⊂P-SPACE",
    "C. NP⊂P-SPACE, NP-zupełne⊂NP-trudne, P⊂NP-trudne",
    "D. P-SPACE⊂P, NP-trudne⊂NP-zupełne, NP⊂NP-trudne"
    ],
    correct:0
    },

    {
    cat:"W1",
    q:"6. (W1/4) Które z podanych równań rekurencyjnych można traktować jako reprezentację złożoności obliczeniowej czasowej algorytmu z rekurencją prostą:",
    options:[
    "A. tylko równanie R2",
    "B. tylko równanie R3",
    "C. równania R2 i R3",
    "D. żadne"
    ],
    correct:2
    },

    {
    cat:"W1",
    q:"7. (W1/5) Czy w przypadku algorytmu rekurencyjnego przeszukiwania tablicy uporządkowanej celem znalezienie pewnego jej elementu jest sens wykorzystywać rekurencję rozgałęzioną?",
    options:[
    "A. tak, bo warto podzielić tablice np. na 2 części i osobno (rekurencyjnie) szukać elementu w obydwu częściach",
    "B. nie, bo po podzieleniu tablicy np. na 2 części wystarczy szukać elementu tylko w jednej z nich (rekurencja prosta)",
    "C. w tym przypadku wybór rekurencji prostej czy rozgałęzionej nie ma znaczenia, bo złożoność obliczeniowa w obydwu przypadkach jest taka sama",
    "D. trudno porównać, bo nie podano o jakie konkretnie algorytmy chodzi"
    ],
    correct:1
    },

    {
    cat:"W1",
    q:"8. (W1/5) Jeśli dla mojego problemu znam algorytm, który ma wykładniczą złożoność obliczeniową czasową, to co mogę zrobić, aby móc rozwiązywać ten problem za pomocą komputera dla dużych rozmiarów problemu?",
    options:[
    "A. zaimplementować ten algorytm w postaci programu i go uruchomić",
    "B. użyć komputera z dużą częstotliwością taktowania procesora",
    "C. użyć komputera z większą liczbą rdzeni lub procesorów",
    "D. wymyśleć i zaimplementować algorytm o niższej złożoności czasowej"
    ],
    correct:3
    },

    {
    cat:"W1",
    q:"9. (W1/5) Jeśli dla mojego problemu znam algorytm, który weryfikuje poprawność rozwiązania dla konkretnych danych wejściowych w pamięci ograniczonej przez pewien wielomian zależny od rozmiaru problemu, to czy da się znaleźć algorytm, który rozwiązuje ten problem w pamięci wielomianowej?",
    options:[
    "A. tak i mówi o tym twierdzenie Cooka",
    "B. nie, bo w takiej sytuacji, z punktu widzenia złożoności obliczeniowej pamięciowej, algorytm może być wykładniczy",
    "C. tak i mówi o tym twierdzenie Savitcha",
    "D. trudno powiedzieć, bo te dwa problemy są różne"
    ],
    correct:2
    },

    /********************* W2 *********************/

    {
    cat:"W2",
    q:"10. (W2/3) Podaj rzędy złożoności obliczeniowej następujących operacji: wstawiania do zrównoważonego drzewa binarnego, wyszukiwania w tablicy dynamicznej uporządkowanej, usuwania z tablicy mieszającej:",
    options:[
    "A. Θ(log n), Θ(log n), Θ(1)",
    "B. Θ(1), Θ(n), Θ(n)",
    "C. Θ(n), Θ(log n), Θ(1)",
    "D. Θ(log n), Θ(n), Θ(1)"
    ],
    correct:0
    },

    {
    cat:"W2",
    q:"11. (W2/3) Strukturą konkretną nadającą się w sposób naturalny do implementacji abstrakcyjnej listy jest:",
    options:[
    "A. tablica dynamiczna",
    "B. tablica mieszająca",
    "C. drzewo binarne",
    "D. lista powiązana"
    ],
    correct:3
    },

    {
    cat:"W2",
    q:"12. (W2/3) Metoda reprezentacji grafów polegająca na tym, że budujemy macierz kwadratową, w której przechowujemy informacje o ewentualnych krawędziach pomiędzy sąsiednimi wierzchołkami w grafie nazywa się:",
    options:[
    "A. metodą sąsiadów",
    "B. metodą sąsiedztwa",
    "C. metodą listy sąsiedztwa",
    "D. żadna z wymienionych"
    ],
    correct:1
    },

    {
    cat:"W2",
    q:"13. (W2/4) Która z poniższych implementacji zbioru będzie miała najszybszą operację usuwania elementu?",
    options:[
    "A. za pomocą tablicy dynamicznej",
    "B. za pomocą uporządkowanej tablicy dynamicznej",
    "C. za pomocą zrównoważonego drzewa binarnego",
    "D. za pomocą listy powiązanej"
    ],
    correct:3
    },

    {
    cat:"W2",
    q:"14. (W2/4) Która z poniższych implementacji zbioru będzie miała najwolniejszą operację wyszukiwania elementów?",
    options:[
    "A. za pomocą tablicy dynamicznej",
    "B. za pomocą uporządkowanej tablicy dynamicznej",
    "C. za pomocą zrównoważonego drzewa binarnego",
    "D. za pomocą tablicy mieszającej"
    ],
    correct:0
    },

    {
    cat:"W2",
    q:"15. (W2/4) Która z poniższych implementacji zbioru będzie miała najwolniejszą operację wstawiania elementów?",
    options:[
    "A. za pomocą tablicy dynamicznej",
    "B. za pomocą uporządkowanej listy powiązanej",
    "C. za pomocą zrównoważonego drzewa binarnego",
    "D. za pomocą tablicy mieszającej"
    ],
    correct:1
    },

    {
    cat:"W2",
    q:"16. (W2/5) Jeśli do reprezentowania danych potrzeba struktury o możliwie szybkim wstawianiu i oszczędności pamięci, a szybkość wyszukiwania i usuwania oraz uporządkowanie elementów w strukturze nie są istotne, to do implementacji takiej struktury zalecane jest użycie:",
    options:[
    "A. tablicy dynamicznej",
    "B. listy powiązanej",
    "C. tablicy mieszającej",
    "D. drzewa binarnego"
    ],
    correct:1
    },

    {
    cat:"W2",
    q:"17. (W2/5) Jeśli do reprezentowania danych potrzeba oszczędnej pamięciowo i uporządkowanej wewnętrznie struktury, a szybkość wstawiania, wyszukiwania i usuwania nie są istotne, to do implementacji takiej struktury zalecane jest użycie:",
    options:[
    "A. tablicy dynamicznej uporządkowanej",
    "B. listy powiązanej uporządkowanej",
    "C. tablicy mieszającej",
    "D. drzewa binarnego"
    ],
    correct:0
    },

    {
    cat:"W2",
    q:"18. (W2/5) Jeśli do reprezentowania danych potrzeba struktury o możliwie szybkim wyszukiwaniu i wstawianiu, a szybkość usuwania oraz uporządkowanie elementów w strukturze oraz oszczędność pamięci nie są istotne, to do implementacji takiej struktury zalecane jest użycie:",
    options:[
    "A. tablicy dynamicznej",
    "B. listy powiązanej",
    "C. tablicy mieszającej",
    "D. drzewa binarnego"
    ],
    correct:2
    },

    /********************* W3 *********************/

    {
    cat:"W3",
    q:"19. (W3/3) Metoda sortowania przez wybór elementów w tablicy n-elementowej jest metodą:",
    options:[
    "A. dokładną",
    "B. aproksymacyjną",
    "C. dokładną i aproksymacyjną",
    "D. trudno powiedzieć"
    ],
    correct:0
    },

    {
    cat:"W3",
    q:"20. (W3/3) Metoda sortowania tablicy, która polega na podzieleniu tablicy danych na dwie równe części, rekurencyjnym sortowaniu osobno każdej z nich oraz ich scaleniu to metoda:",
    options:[
    "A. bąbelkowa",
    "B. przez wybór",
    "C. przez wstawianie",
    "D. żadna z wymienionych"
    ],
    correct:3
    },

    {
    cat:"W3",
    q:"21. (W3/3) Metoda przeszukiwania grafów polegająca na odwiedzeniu wszystkich wierzchołków osiągalnych z wierzchołka początkowego warstwami, gdzie dana warstwa oznacza wierzchołki tak samo odległe od zadanego wierzchołka jest metodą:",
    options:[
    "A. przeszukiwania grafu wszerz",
    "B. przeszukiwania grafu w głąb",
    "C. programowania dynamicznego",
    "D. żadna z wymienionych"
    ],
    correct:0
    },

    {
    cat:"W3",
    q:"22. (W3/4) Zgodnie z twierdzeniem na temat dolnego ograniczenia na pesymistyczny czas sortowania, algorytmem sortowania o optymalnej złożoności obliczeniowej jest algorytm:",
    options:[
    "A. przez scalanie",
    "B. przez wybór",
    "C. przez wstawianie",
    "D. żaden z wymienionych"
    ],
    correct:0
    },

    {
    cat:"W3",
    q:"23. (W3/4) Które z poniższych stwierdzeń dotyczących metod konstrukcji algorytmów jest fałszywe:",
    options:[
    "A. jeśli algorytm zachłanny nie jest efektywny czasowo dla danego problemu, to sensowne jest zastosować metodę Monte Carlo",
    "B. metoda błądzenia losowego jest rodzajem metody Monte Carlo",
    "C. oprócz metody brutalnej siły, żadna inna metoda nie potrafi znaleźć tak dokładnych rozwiązań problemów",
    "D. metoda programowania dynamicznego jest odmianą metody dziel i zwyciężaj"
    ],
    correct:2
    },

    {
    cat:"W3",
    q:"24. (W3/4) Jeśli w algorytmie przeszukiwania grafów wszerz zależy nam na tym, aby rozmiar zbioru wierzchołków miał jak najmniejszy wpływ na wzrost złożoności obliczeniowej pamięciowej, to do reprezentacji grafu używamy:",
    options:[
    "A. listy sąsiedztwa",
    "B. macierzy sąsiedztwa",
    "C. lista lub macierz sąsiedztwa (są tak samo efektywne)",
    "D. reprezentacja grafu nie ma tutaj wpływu"
    ],
    correct:0
    },

    {
    cat:"W3",
    q:"25. (W3/5) Jeśli przestrzeń stanów dla danego problemu jest bardzo duża, ale nie zależy nam na rozwiązaniu dokładnym problemu, to należy stosować metody:",
    options:[
    "A. metodę brutalnej siły",
    "B. metodę Monte Carlo",
    "C. metodę dziel i zwyciężaj",
    "D. żadna z wymienionych"
    ],
    correct:1
    },

    {
    cat:"W3",
    q:"26. (W3/5) Jeśli problem komiwojażera dotyczy 10000 miast, to jaka metoda nie może być użyta do rozwiązania tego problemu?",
    options:[
    "A. metoda przeszukiwania z nawrotami",
    "B. algorytm zachłanny",
    "C. metoda Monte Carlo",
    "D. metoda brutalnej siły (przeglądanie wszystkich permutacji miast)"
    ],
    correct:3
    },

    {
    cat:"W3",
    q:"27. (W3/5) Jeśli elementami sortowanej tablicy są liczby całkowite z przedziału 0..k-1 dla pewnego naturalnego k, to jaka metoda sortowania będzie najbardziej efektywna czasowo dla tej tablicy:",
    options:[
    "A. metoda sortowania przez wybór",
    "B. metoda sortowania przez zliczanie",
    "C. metoda sortowania przez scalanie",
    "D. metoda szybkiego sortowania"
    ],
    correct:1
    },

    /********************* W4 *********************/

    {
    cat:"W4",
    q:"28. (W4/3) Która z poniższych metod jest metodą dowodzenia częściowej poprawności algorytmów:",
    options:[
    "A. metoda liczników iteracji",
    "B. metoda malejących wielkości",
    "C. metoda niezmienników iteracji",
    "D. żadna z wymienionych"
    ],
    correct:2
    },

    {
    cat:"W4",
    q:"29. (W4/3) Warunek logiczny, który opisuje własność poprawnych wyników algorytmu oraz ich związek z danymi nazywa się:",
    options:[
    "A. warunkiem rozpoczęcia",
    "B. warunkiem początkowym",
    "C. warunkiem końcowym",
    "D. warunkiem stopu"
    ],
    correct:2
    },

    {
    cat:"W4",
    q:"30. (W4/3) Własność algorytmu polegająca na tym, że dla każdych danych wejściowych spełniających warunek początkowy obliczenie jest skończone nosi nazwę:",
    options:[
    "A. własności początkowej",
    "B. własności określoności",
    "C. własności końcowej",
    "D. żadna z wymienionych"
    ],
    correct:3
    },

    {
    cat:"W4",
    q:"31. (W4/4) Metoda dowodu własności stopu algorytmu z pętlą opierająca się na założeniu, że jeśli w kolejnych iteracjach pętli dana wielkość jest coraz mniejsza i dodatkowo jest ograniczona od dołu, to pętla kiedyś się zakończy, co oznacza, że obliczenie będzie skończone, nazywa się:",
    options:[
    "A. metodą liczników iteracji",
    "B. metodą malejących wielkości",
    "C. metodą niezmienników iteracji",
    "D. żadna z wymienionych"
    ],
    correct:1
    },

    {
    cat:"W4",
    q:"32. (W4/4) Która z poniższych trójek operacji zawiera tylko operacje, które nie zagrażają własności określoności algorytmu (bez uwzględniania problemu przekroczenia zakresu wartości dla typu liczbowego):",
    options:[
    "A. dodawanie, odejmowanie, mnożenie",
    "B. mnożenie, dzielenie, pierwiastkowanie",
    "C. pierwiastkowanie, dzielenie, logarytmowanie",
    "D. logarytmowanie, mnożenie, dodawanie"
    ],
    correct:0
    },

    {
    cat:"W4",
    q:"33. (W4/4) Dowód częściowej poprawności algorytmu względem warunku początkowego i końcowego metodą niezmienników iteracji polega na:",
    options:[
    "A. wykazaniu indukcyjnym ze względu na liczbę iteracji pętli, że po każdej iteracji pętli spełniony jest warunek końcowy",
    "B. sprawdzaniu w określonych miejscach algorytmu czy spełniona jest pewna funkcja zdaniowa zależna od wartości m, gdzie przez m rozumiemy m-tą iterację algorytmu",
    "C. sprawdzaniu poprawności uzyskanego wyniku przez algorytm w oparciu o porównanie ze znanym poprawnym wynikiem uzyskanym inną metodą",
    "D. żadne z powyższych wyjaśnień nie jest do końca poprawne"
    ],
    correct:3
    },

    {
    cat:"W4",
    q:"34. (W4/5) Jeśli program, który sprawdza występowanie pewnego elementu w tablicy zawiesił się, to znaczy że nie sprawdzono dla tego programu własności:",
    options:[
    "A. częściowej poprawności",
    "B. stopu",
    "C. określoności",
    "D. żadnej z wymienionych"
    ],
    correct:1
    },

    {
    cat:"W4",
    q:"35. (W4/5) Jeśli program, który ma wyliczać maksimum elementów pewnego zbioru liczb całkowitych policzył minimum tego zbioru, to znaczy że nie sprawdzono dla tego programu własności:",
    options:[
    "A. częściowej poprawności",
    "B. stopu",
    "C. określoności",
    "D. żadnej z wymienionych"
    ],
    correct:0
    },

    {
    cat:"W4",
    q:"36. (W4/5) Jeśli w programie komputerowym zdarzył się błąd próby wyliczenia pierwiastka kwadratowego z liczby ujemnej, to znaczy że nie sprawdzono dla tego programu własności:",
    options:[
    "A. częściowej poprawności",
    "B. stopu",
    "C. określoności",
    "D. żadnej z wymienionych"
    ],
    correct:2
    },

];


    let currentIdx = 0;
    let correctCount = 0;
    let wrongCount = 0;
    
    // Zmienne do zliczania punktów w sekcjach
    let scores = { w1:0, w2:0, w3:0, w4:0 };

    const qText = document.getElementById("question-text");
    const catLabel = document.getElementById("category-label");
    const optionsContainer = document.getElementById("options-container");
    const nextBtn = document.getElementById("next-btn");
    const progressFill = document.getElementById("progress");
    const counterDiv = document.getElementById("counter");
    const correctDiv = document.getElementById("correct-count");
    const wrongDiv = document.getElementById("wrong-count");

    function renderQuestion() {
        if(currentIdx >= questions.length) {
            showResults();
            return;
        }

        const q = questions[currentIdx];
        qText.innerText = q.q;
        catLabel.innerText = q.cat;
        
        counterDiv.innerText = `${currentIdx + 1} / ${questions.length}`;
        let progressPct = (currentIdx / questions.length) * 100;
        progressFill.style.width = `${progressPct}%`;

        optionsContainer.innerHTML = "";
        nextBtn.style.display = "none";

        q.options.forEach((opt, idx) => {
            const btn = document.createElement("button");
            btn.className = "option-btn";
            
            const letter = String.fromCharCode(65 + idx); // A, B, C...
            btn.innerHTML = `<span class="option-letter">${letter}.</span> ${opt}`;
            
            btn.onclick = () => checkAnswer(btn, idx, q.correct);
            optionsContainer.appendChild(btn);
        });
    }

    function checkAnswer(selectedBtn, selectedIdx, correctIdx) {
        // Zablokuj wszystkie
        const allBtns = optionsContainer.querySelectorAll(".option-btn");
        allBtns.forEach(btn => btn.classList.add("disabled"));

        if (selectedIdx === correctIdx) {
            selectedBtn.classList.add("correct");
            correctCount++;
            correctDiv.innerText = correctCount;
            // Zliczanie do sekcji
            if(currentIdx < 9) scores.w1++;
            else if(currentIdx < 18) scores.w2++;
            else if(currentIdx < 27) scores.w3++;
            else scores.w4++;
        } else {
            selectedBtn.classList.add("wrong");
            // Pokaż poprawną
            allBtns[correctIdx].classList.add("correct");
            // Usuń klasę disabled z poprawnej żeby było widać kolor wyraźnie
            allBtns[correctIdx].classList.remove("disabled");
            wrongCount++;
            wrongDiv.innerText = wrongCount;
        }

        nextBtn.style.display = "block";
    }

    function nextQuestion() {
        currentIdx++;
        renderQuestion();
    }

    function showResults() {
        document.getElementById("quiz-container").style.display = "none";
        const resScreen = document.getElementById("results-screen");
        resScreen.style.display = "block";
        
        const details = document.getElementById("results-details");
        
        const checkPass = (score) => score >= 3 ? "<span class='pass'>ZALICZONE</span>" : "<span class='fail'>NIEZALICZONE</span>";

        details.innerHTML = `
            <div class="result-item">Efekt W1 (Złożoność): ${scores.w1}/9 - ${checkPass(scores.w1)}</div>
            <div class="result-item">Efekt W2 (Struktury): ${scores.w2}/9 - ${checkPass(scores.w2)}</div>
            <div class="result-item">Efekt W3 (Algorytmy): ${scores.w3}/9 - ${checkPass(scores.w3)}</div>
            <div class="result-item">Efekt W4 (Poprawność): ${scores.w4}/9 - ${checkPass(scores.w4)}</div>
            <br>
            <div class="result-item">Łączny wynik: <b>${correctCount}</b> / 36</div>
        `;
    }

    // Start
    renderQuestion();

</script>

</body>
</html>